# -*- coding: utf-8 -*-

import sys
import math
import socket
import struct
import base64
import traceback
import numpy
import os
import pickle
import imp
import types
from datetime import datetime
from pandas import DataFrame

# import modules generated by protobuf
import table_pb2
import command_pb2
import autocompletesuggestions_pb2
import simpleresponse_pb2
import variablelist_pb2
import image_pb2
import executeresponse_pb2
import pickledobject_pb2

# check if we are running python 2 or python 3
_python3 = sys.version_info >= (3, 0)

if _python3:
    from io import StringIO
else:
    from StringIO import StringIO

try:
    from pandas.tslib import Timestamp
    from pandas.tslib import NaT
    _tslib_available = True
except ImportError:
    _tslib_available = False

# load jedi for auto completion if available
try:
    import jedi
    _jedi_available = True
except ImportError:
    _jedi_available = False

# global variables in the execution environment
_global_env = {}
# local variables in the execution environment
_local_env = {}
# TCP connection
_connection = None

# list of equivalent types
EQUIVALENT_TYPES = [
    [unicode, str],
    [int, long]
]
if _tslib_available:
    EQUIVALENT_TYPES.append([datetime, Timestamp])


# connect to the server on the localhost at the port given by the argument 1 and listen for commands
def run():
    global _connection
    _connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    _connection.connect(('localhost', int(sys.argv[1])))
    # First send PID of this process (so it can reliably be killed later)
    pid_response = simpleresponse_pb2.SimpleResponse()
    pid_response.integer = os.getpid()
    write_message(pid_response)
    try:
        while 1:
            command = read_next_command()
            if command.HasField('execute'):
                execute_response = executeresponse_pb2.ExecuteResponse()
                execute_response.output, execute_response.error = execute(command.execute.sourceCode)
                write_message(execute_response)
            elif command.HasField('putFlowVariables'):
                flow_variables = {}
                for variable in command.putFlowVariables.integerVariable:
                    flow_variables[variable.key] = variable.value
                for variable in command.putFlowVariables.doubleVariable:
                    flow_variables[variable.key] = variable.value
                for variable in command.putFlowVariables.stringVariable:
                    flow_variables[variable.key] = variable.value
                put_variable('flow_variables', flow_variables)
                write_dummy()
            elif command.HasField('putTable'):
                try:
                    frame = protobuf_table_to_data_frame(command.putTable.table)
                    put_variable(command.putTable.key, frame)
                except BaseException as e:
                    simple_response = simpleresponse_pb2.SimpleResponse()
                    simple_response.string = str(e)
                    write_message(simple_response)
                    raise e
                simple_response = simpleresponse_pb2.SimpleResponse()
                write_message(simple_response)
            elif command.HasField('appendToTable'):
                frame = protobuf_table_to_data_frame(command.appendToTable.table)
                append_to_table(command.appendToTable.key, frame)
                write_dummy()
            elif command.HasField('getTable'):
                frame = get_variable(command.getTable.key)
                if type(frame) is not DataFrame:
                    simple_response = simpleresponse_pb2.SimpleResponse()
                    simple_response.integer = 0
                    write_message(simple_response)
                    table = table_pb2.Table()
                    table.valid = False
                    table.numCols = 0
                    table.numRows = 0
                    if frame is None:
                        table.error = command.getTable.key + ' is not defined'
                    else:
                        table.error = command.getTable.key + ' is not a table'
                    write_message(table)
                else:
                    chunk_size = command.getTable.chunkSize
                    num_chunks = int(math.ceil(float(len(frame.index))/float(chunk_size)))
                    if num_chunks == 0:
                        # this happens if the table has no rows, we still want to send the specs
                        num_chunks = 1
                    simple_response = simpleresponse_pb2.SimpleResponse()
                    simple_response.integer = len(frame.index)
                    write_message(simple_response)
                    for chunk in range(num_chunks):
                        table = data_frame_to_protobuf_table(frame[chunk*chunk_size:(chunk+1)*chunk_size])
                        write_message(table)
            elif command.HasField('listVariables'):
                variable_list = variablelist_pb2.VariableList()
                variables = list_variables()
                for var in variables:
                    variable = variable_list.variable.add()
                    variable.key = var['name']
                    variable.type = var['type']
                    variable.value = var['value']
                write_message(variable_list)
            elif command.HasField('reset'):
                reset()
            elif command.HasField('hasAutoComplete'):
                simple_response = simpleresponse_pb2.SimpleResponse()
                simple_response.boolean = has_auto_complete()
                write_message(simple_response)
            elif command.HasField('autoComplete'):
                autocomplete_suggestions = autocompletesuggestions_pb2.AutocompleteSuggestions()
                suggestions = auto_complete(command.autoComplete.sourceCode, command.autoComplete.line,
                                            command.autoComplete.column)
                for suggestion in suggestions:
                    autocomplete_suggestion = autocomplete_suggestions.autocompleteSuggestion.add()
                    autocomplete_suggestion.name = suggestion['name']
                    autocomplete_suggestion.type = suggestion['type']
                    autocomplete_suggestion.doc = suggestion['doc']
                write_message(autocomplete_suggestions)
            elif command.HasField('getImage'):
                image = get_variable(command.getImage.key)
                img = image_pb2.Image()
                if image is None:
                    img.error = command.getImage.key + ' is not defined'
                    img.bytes = ''
                elif type(image) is str:
                    img.bytes = image
                else:
                    img.error = command.getImage.key + ' is not an image'
                    img.bytes = ''
                write_message(img)
            elif command.HasField('getObject'):
                object = get_variable(command.getObject.key)
                pickled_object = pickledobject_pb2.PickledObject()
                pickled_object.pickledObject = pickle.dumps(object)
                pickled_object.type = type(object).__name__
                pickled_object.stringRepresentation = str(object)
                write_message(pickled_object)
            elif command.HasField('putObject'):
                object = pickle.loads(command.putObject.pickledObject)
                put_variable(command.putObject.key, object)
                write_dummy()
            elif command.HasField('loadTypeExtensions'):
                for type_extension in command.loadTypeExtensions.typeExtension:
                    _type_extension_manager.add_type_extension(type_extension.id, type_extension.type, type_extension.path)
                write_dummy()
    finally:
        _connection.close()


# reads 4 bytes from the input stream and interprets them as size
def read_size():
    data = ''
    while len(data) < 4:
        data += _connection.recv(4)
    return struct.unpack('>L', data)[0]


# read the next command message from the input stream
def read_next_command():
    size = read_size()
    data = ''
    while len(data) < size:
        data += _connection.recv(size)
    command = command_pb2.Command()
    command.ParseFromString(data)
    return command


# writes the given size as 4 byte integer to the output stream
def write_size(size):
    _connection.sendall(struct.pack('>L', size))


# writes the given message to the output stream
def write_message(message):
    message_string = message.SerializeToString()
    write_size(len(message_string))
    _connection.sendall(message_string)


# writes an empty message
def write_dummy():
    write_size(0)


# execute the given source code
def execute(source_code):
    output = StringIO()
    error = StringIO()
    sys.stdout = output
    # run execute with the provided source code
    try:
        exec(source_code, _global_env, _local_env)
    except Exception:
        traceback.print_exc(file=error)
    sys.stdout = sys.__stdout__
    return [output.getvalue(), error.getvalue()]


# put the given variable into the local environment under the given name
def put_variable(name, variable):
    _local_env[name] = variable


# append the given data frame to an existing one
def append_to_table(name, data_frame):
    _local_env[name] = _local_env[name].append(data_frame)


# get the variable with the given name
def get_variable(name):
    if name in _local_env:
        return _local_env[name]
    else:
        return None


# list all currently loaded modules and defined classes, functions and variables
def list_variables():
    # create lists of modules, classes, functions and variables
    modules = []
    classes = []
    functions = []
    variables = []
    # iterate over dictionary to and put modules, classes, functions and variables in their respective lists
    for key, value in dict(_local_env).items():
        # get name of the type
        var_type = type(value).__name__
        # class type changed from classobj to type in python 3
        class_type = 'classobj'
        if _python3:
            class_type = 'type'
        if var_type == 'module':
            modules.append({'name': key, 'type': var_type, 'value': ''})
        elif var_type == class_type:
            classes.append({'name': key, 'type': var_type, 'value': ''})
        elif var_type == 'function':
            functions.append({'name': key, 'type': var_type, 'value': ''})
        else:
            try:
                value = unicode(value)
            except UnicodeDecodeError:
                value = '(base64 encoded)\n' + base64.b64encode(value)
            variables.append({'name': key, 'type': var_type, 'value': value})
    # sort lists by name
    modules = sorted(modules, key=lambda k: k['name'])
    classes = sorted(classes, key=lambda k: k['name'])
    functions = sorted(functions, key=lambda k: k['name'])
    variables = sorted(variables, key=lambda k: k['name'])
    # create response list and add contents of the other lists in the order they should be displayed
    response = []
    response.extend(modules)
    response.extend(classes)
    response.extend(functions)
    response.extend(variables)
    return response


# reset the current environment
def reset():
    # reset environment by emptying variable definitions
    global _global_env, _local_env
    _global_env = {}
    _local_env = {}


# returns true if auto complete is available, false otherwise
def has_auto_complete():
    return _jedi_available


# returns a list of auto suggestions for the given code at the given cursor position
def auto_complete(source_code, line, column):
    response = []
    if has_auto_complete():
        # get possible completions by using Jedi and providing the source code, and the cursor position
        # note: the line number (argument 2) gets incremented by 1 since Jedi's line numbering starts at 1
        completions = jedi.Script(source_code, line + 1, column, None).completions()
        # extract interesting information
        for index, completion in enumerate(completions):
            response.append({'name': completion.name, 'type': completion.type, 'doc': completion.doc})
    return response


# converts a protobuf table message to a pandas.DataFrame
def protobuf_table_to_data_frame(table_message):
    data = {}
    column_names = []
    for colRef in table_message.colRef:
        if colRef.type == 'BooleanColumn':
            column = table_message.booleanCol[colRef.indexInType]
            cells = []
            for value in column.booleanValue:
                if value.HasField('value'):
                    cells.append(value.value)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'IntegerColumn':
            column = table_message.integerCol[colRef.indexInType]
            cells = []
            for value in column.integerValue:
                if value.HasField('value'):
                    cells.append(value.value)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'LongColumn':
            column = table_message.longCol[colRef.indexInType]
            cells = []
            for value in column.longValue:
                if value.HasField('value'):
                    cells.append(value.value)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'DoubleColumn':
            column = table_message.doubleCol[colRef.indexInType]
            cells = []
            for value in column.doubleValue:
                if value.HasField('value'):
                    cells.append(value.value)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'StringColumn':
            column = table_message.stringCol[colRef.indexInType]
            cells = []
            for value in column.stringValue:
                if value.HasField('value'):
                    cells.append(value.value)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'DateAndTimeColumn':
            column = table_message.dateAndTimeCol[colRef.indexInType]
            cells = []
            for value in column.dateAndTimeValue:
                if value.HasField('year'):
                    try:
                        cells.append(datetime(value.year, value.month, value.day, value.hour, value.minute,
                                              value.second, value.millisecond * 1000))
                    except ValueError:
                        cells.append(None)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'BooleanListColumn':
            column = table_message.booleanListCol[colRef.indexInType]
            cells = []
            for value in column.booleanListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('value'):
                            collection_cell.append(single_value.value)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'IntegerListColumn':
            column = table_message.integerListCol[colRef.indexInType]
            cells = []
            for value in column.integerListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('value'):
                            collection_cell.append(single_value.value)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'LongListColumn':
            column = table_message.longListCol[colRef.indexInType]
            cells = []
            for value in column.longListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('value'):
                            collection_cell.append(single_value.value)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'DoubleListColumn':
            column = table_message.doubleListCol[colRef.indexInType]
            cells = []
            for value in column.doubleListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('value'):
                            collection_cell.append(single_value.value)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'DateAndTimeListColumn':
            column = table_message.dateAndTimeListCol[colRef.indexInType]
            cells = []
            for value in column.dateAndTimeListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('year'):
                            try:
                                collection_cell.append(datetime(single_value.year, single_value.month, single_value.day,
                                                                single_value.hour, single_value.minute,
                                                                single_value.second, single_value.millisecond * 1000))
                            except ValueError:
                                collection_cell.append(None)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'StringListColumn':
            column = table_message.stringListCol[colRef.indexInType]
            cells = []
            for value in column.stringListValue:
                if not value.isMissing:
                    collection_cell = []
                    for single_value in value.value:
                        if single_value.HasField('value'):
                            collection_cell.append(single_value.value)
                        else:
                            collection_cell.append(None)
                    if column.isSet:
                        collection_cell = set(collection_cell)
                    cells.append(collection_cell)
                else:
                    cells.append(None)
            data[column.name] = cells
            column_names.append(column.name)
        elif colRef.type == 'ObjectListColumn':
            column = table_message.objectListCol[colRef.indexInType]
            type_extension = _type_extension_manager.get_type_extension_by_id(column.type)
            if type_extension is not None:
                cells = []
                for value in column.objectListValue:
                    if not value.isMissing:
                        collection_cell = []
                        for single_value in value.value:
                            if single_value.HasField('value'):
                                collection_cell.append(type_extension.deserialize(single_value.value))
                            else:
                                collection_cell.append(None)
                        if column.isSet:
                            collection_cell = set(collection_cell)
                        cells.append(collection_cell)
                    else:
                        cells.append(None)
                data[column.name] = cells
                column_names.append(column.name)
        elif colRef.type == 'ObjectColumn':
            column = table_message.objectCol[colRef.indexInType]
            cells = []
            type_extension = _type_extension_manager.get_type_extension_by_id(column.type)
            if type_extension is not None:
                for value in column.objectValue:
                    if value.HasField('value'):
                        cells.append(type_extension.deserialize(value.value))
                    else:
                        cells.append(None)
                data[column.name] = cells
                column_names.append(column.name)
    return DataFrame(data, index=table_message.rowId, columns=column_names)


# converts a pandas.DataFrame to a protobuf table message
def data_frame_to_protobuf_table(data_frame):
    try:
        table_message = table_pb2.Table()
        table_message.valid = True
        table_message.numRows = len(data_frame.index)
        if len(data_frame.index) == 0:
            # if table is empty we don't know the types so we make them strings
            for column in data_frame.columns:
                col_ref = table_message.colRef.add()
                col_ref.type = 'StringColumn'
                col_ref.indexInType = len(table_message.stringCol)
                string_col = table_message.stringCol.add()
                string_col.name = str(column)
        else:
            for index in data_frame.index:
                table_message.rowId.append(str(index))
            for column in data_frame.columns:
                col_ref = table_message.colRef.add()
                if data_frame[column].dtype == 'bool':
                    # This is only the case when the column contains no None
                    col_ref.type = 'BooleanColumn'
                    col_ref.indexInType = len(table_message.booleanCol)
                    boolean_col = table_message.booleanCol.add()
                    boolean_col.name = str(column)
                    for cell in data_frame[column]:
                        boolean_val = boolean_col.booleanValue.add()
                        boolean_val.value = bool(cell)
                elif data_frame[column].dtype == 'int64' or data_frame[column].dtype == 'int32':
                    minvalue = data_frame[column][data_frame[column].idxmin()]
                    maxvalue = data_frame[column][data_frame[column].idxmax()]
                    int32min = -2147483648
                    int32max = 2147483647
                    if minvalue >= int32min and maxvalue <= int32max:
                        col_ref.type = 'IntegerColumn'
                        col_ref.indexInType = len(table_message.integerCol)
                        integer_col = table_message.integerCol.add()
                        integer_col.name = str(column)
                        for cell in data_frame[column]:
                            integer_val = integer_col.integerValue.add()
                            if not math.isnan(cell):
                                integer_val.value = int(cell)
                    else:
                        col_ref.type = 'LongColumn'
                        col_ref.indexInType = len(table_message.longCol)
                        long_col = table_message.longCol.add()
                        long_col.name = str(column)
                        for cell in data_frame[column]:
                            long_val = long_col.longValue.add()
                            if not math.isnan(cell):
                                long_val.value = long(cell)
                elif data_frame[column].dtype == 'double':
                    col_ref.type = 'DoubleColumn'
                    col_ref.indexInType = len(table_message.doubleCol)
                    double_col = table_message.doubleCol.add()
                    double_col.name = str(column)
                    for cell in data_frame[column]:
                        double_val = double_col.doubleValue.add()
                        if not math.isnan(cell):
                            double_val.value = cell
                else:
                    col_type = column_type(data_frame, column)
                    if col_type is None:
                        # column with only missing values, make it string
                        col_type = str
                    if types_are_equivalent(col_type, bool):
                        col_ref.type = 'BooleanColumn'
                        col_ref.indexInType = len(table_message.booleanCol)
                        boolean_col = table_message.booleanCol.add()
                        boolean_col.name = str(column)
                        for cell in data_frame[column]:
                            boolean_val = boolean_col.booleanValue.add()
                            if not is_missing(cell):
                                boolean_val.value = bool(cell)
                    elif types_are_equivalent(col_type, str):
                        col_ref.type = 'StringColumn'
                        col_ref.indexInType = len(table_message.stringCol)
                        string_col = table_message.stringCol.add()
                        string_col.name = str(column)
                        for cell in data_frame[column]:
                            string_val = string_col.stringValue.add()
                            if not is_missing(cell):
                                string_val.value = cell
                    elif types_are_equivalent(col_type, datetime):
                        col_ref.type = 'DateAndTimeColumn'
                        col_ref.indexInType = len(table_message.dateAndTimeCol)
                        date_and_time_col = table_message.dateAndTimeCol.add()
                        date_and_time_col.name = str(column)
                        for cell in data_frame[column]:
                            date_and_time_val = date_and_time_col.dateAndTimeValue.add()
                            if not is_missing(cell):
                                date_and_time_val.year = cell.year
                                date_and_time_val.month = cell.month
                                date_and_time_val.day = cell.day
                                date_and_time_val.hour = cell.hour
                                date_and_time_val.minute = cell.minute
                                date_and_time_val.second = cell.second
                                date_and_time_val.millisecond = int(round(float(cell.microsecond)/1000.0))
                    elif col_type is list or col_type is set:
                        is_set = col_type is set
                        list_col_type = list_column_type(data_frame, column)
                        if list_col_type is None:
                            # column with only missing values, make it string
                            list_col_type = str
                        if types_are_equivalent(list_col_type, bool):
                            col_ref.type = 'BooleanListColumn'
                            col_ref.indexInType = len(table_message.booleanListCol)
                            boolean_list_col = table_message.booleanListCol.add()
                            boolean_list_col.isSet = is_set
                            boolean_list_col.name = str(column)
                            for cell in data_frame[column]:
                                boolean_list_val = boolean_list_col.booleanListValue.add()
                                boolean_list_val.isMissing = cell is None
                                if cell is not None:
                                    for single_cell in cell:
                                        boolean_val = boolean_list_val.value.add()
                                        if not is_missing(single_cell):
                                            boolean_val.value = bool(single_cell)
                        elif types_are_equivalent(list_col_type, int):
                            minvalue = 0
                            maxvalue = 0
                            for list_cell in data_frame[column]:
                                if list_cell is not None:
                                    for cell in list_cell:
                                        if cell is not None:
                                            minvalue = min(minvalue, cell)
                                            maxvalue = max(maxvalue, cell)
                            int32min = -2147483648
                            int32max = 2147483647
                            if minvalue >= int32min and maxvalue <= int32max:
                                col_ref.type = 'IntegerListColumn'
                                col_ref.indexInType = len(table_message.integerListCol)
                                integer_list_col = table_message.integerListCol.add()
                                integer_list_col.isSet = is_set
                                integer_list_col.name = str(column)
                                for cell in data_frame[column]:
                                    integer_list_val = integer_list_col.integerListValue.add()
                                    integer_list_val.isMissing = cell is None
                                    if cell is not None:
                                        for single_cell in cell:
                                            integer_val = integer_list_val.value.add()
                                            if not is_missing(single_cell):
                                                integer_val.value = int(single_cell)
                            else:
                                col_ref.type = 'LongListColumn'
                                col_ref.indexInType = len(table_message.longListCol)
                                long_list_col = table_message.longListCol.add()
                                long_list_col.isSet = is_set
                                long_list_col.name = str(column)
                                for cell in data_frame[column]:
                                    long_list_val = long_list_col.longListValue.add()
                                    long_list_val.isMissing = cell is None
                                    if cell is not None:
                                        for single_cell in cell:
                                            long_val = long_list_val.value.add()
                                            if not is_missing(single_cell):
                                                long_val.value = long(single_cell)
                        elif types_are_equivalent(list_col_type, float):
                            col_ref.type = 'DoubleListColumn'
                            col_ref.indexInType = len(table_message.doubleListCol)
                            double_list_col = table_message.doubleListCol.add()
                            double_list_col.isSet = is_set
                            double_list_col.name = str(column)
                            for cell in data_frame[column]:
                                double_list_val = double_list_col.doubleListValue.add()
                                double_list_val.isMissing = cell is None
                                if cell is not None:
                                    for single_cell in cell:
                                        double_val = double_list_val.value.add()
                                        if not is_missing(single_cell):
                                            double_val.value = float(single_cell)
                        elif list_col_type is datetime:
                            col_ref.type = 'DateAndTimeListColumn'
                            col_ref.indexInType = len(table_message.dateAndTimeListCol)
                            date_and_time_list_col = table_message.dateAndTimeListCol.add()
                            date_and_time_list_col.isSet = is_set
                            date_and_time_list_col.name = str(column)
                            for cell in data_frame[column]:
                                date_and_time_list_val = date_and_time_list_col.dateAndTimeListValue.add()
                                date_and_time_list_val.isMissing = cell is None
                                if cell is not None:
                                    for single_cell in cell:
                                        date_and_time_val = date_and_time_list_val.value.add()
                                        if not is_missing(single_cell):
                                            date_and_time_val.year = single_cell.year
                                            date_and_time_val.month = single_cell.month
                                            date_and_time_val.day = single_cell.day
                                            date_and_time_val.hour = single_cell.hour
                                            date_and_time_val.minute = single_cell.minute
                                            date_and_time_val.second = single_cell.second
                                            date_and_time_val.millisecond =\
                                                int(round(float(single_cell.microsecond)/1000.0))
                        elif types_are_equivalent(list_col_type, str):
                            col_ref.type = 'StringListColumn'
                            col_ref.indexInType = len(table_message.stringListCol)
                            string_list_col = table_message.stringListCol.add()
                            string_list_col.isSet = is_set
                            string_list_col.name = str(column)
                            for cell in data_frame[column]:
                                string_list_val = string_list_col.stringListValue.add()
                                string_list_val.isMissing = cell is None
                                if cell is not None:
                                    for single_cell in cell:
                                        string_val = string_list_val.value.add()
                                        if not is_missing(single_cell):
                                            string_val.value = single_cell
                        else:
                            type_string = get_type_string(first_valid_list_object(data_frame, column))
                            type_extension = _type_extension_manager.get_type_extension_by_type(type_string)
                            if (type_extension is None):
                                raise ValueError('List column ' + str(column) + ' has unsupported type ' + type_string)
                            col_ref.type = 'ObjectListColumn'
                            col_ref.indexInType = len(table_message.objectListCol)
                            object_list_col = table_message.objectListCol.add()
                            object_list_col.isSet = is_set
                            object_list_col.name = str(column)
                            object_col.type = _type_extension_manager.get_id_by_type(type_string)
                            for cell in data_frame[column]:
                                object_list_val = object_list_col.objectListValue.add()
                                object_list_val.isMissing = cell is None
                                if cell is not None:
                                    for single_cell in cell:
                                        object_val = object_list_val.value.add()
                                        if not is_missing(single_cell):
                                            object_val.value = type_extension.serialize(single_cell)
                    else:
                        type_string = get_type_string(first_valid_object(data_frame, column))
                        type_extension = _type_extension_manager.get_type_extension_by_type(type_string)
                        if (type_extension is None):
                            raise ValueError('Column ' + str(column) + ' has unsupported type ' + type_string)
                        col_ref.type = 'ObjectColumn'
                        col_ref.indexInType = len(table_message.objectCol)
                        object_col = table_message.objectCol.add()
                        object_col.name = str(column)
                        object_col.type = _type_extension_manager.get_id_by_type(type_string)
                        for cell in data_frame[column]:
                            object_val = object_col.objectValue.add()
                            if not is_missing(cell):
                                object_val.value = type_extension.serialize(cell)
        table_message.numCols = len(table_message.colRef)
        return table_message
    except ValueError as e:
        table_message = table_pb2.Table()
        table_message.valid = False
        table_message.error = str(e)
        table_message.numCols = 0
        table_message.numRows = 0
        return table_message


# get the type of a column (fails if multiple types are found)
def column_type(data_frame, column_name):
    col_type = None
    for cell in data_frame[column_name]:
        if not is_missing(cell):
            if col_type is not None:
                if not types_are_equivalent(type(cell), col_type):
                    raise ValueError('More than one type in column ' + str(column_name) + '. Found '
                                     + col_type.__name__ + ' and ' + type(cell).__name__)
            else:
                col_type = type(cell)
    return col_type


# get the type of a list column (fails if multiple types are found)
def list_column_type(data_frame, column_name):
    col_type = None
    for list_cell in data_frame[column_name]:
        if list_cell is not None:
            for cell in list_cell:
                if not is_missing(cell):
                    if col_type is not None:
                        if not types_are_equivalent(type(cell), col_type):
                            raise ValueError('More than one type in column ' + str(column_name) + '. Found '
                                             + col_type.__name__ + ' and ' + type(cell).__name__)
                    else:
                        col_type = type(cell)
    return col_type


def first_valid_object(data_frame, column_name):
    for cell in data_frame[column_name]:
        if not is_missing(cell):
            return cell
    return None


def first_valid_list_object(data_frame, column_name):
    for list_cell in data_frame[column_name]:
        if list_cell is not None:
            for cell in list_cell:
                if not is_missing(cell):
                    return cell
    return None


# checks if the two given types are equivalent based on the equivalence list and the equivalence of numpy types to
# python types
def types_are_equivalent(type_1, type_2):
    for pair in EQUIVALENT_TYPES:
        if type_1 is pair[0] and type_2 is pair[1]:
            return True
        if type_1 is pair[1] and type_2 is pair[0]:
            return True
    if is_collection(type_1) or is_collection(type_2):
        return type_1 is type_2
    if is_numpy_type(type_1) or is_numpy_type(type_2):
        return numpy.issubdtype(type_1, type_2) and numpy.issubdtype(type_2, type_1)
    else:
        return type_1 is type_2


# checks if the given type is a collection type
def is_collection(type):
    return type is list or type is set or type is dict or type is tuple


# checks if the given type is a numpy type
def is_numpy_type(type):
    return type.__module__ == numpy.__name__


# checks if the given value is None, NaN or NaT
def is_missing(value):
    return value is None or is_nat(value) or is_nan(value)


def is_nat(value):
    if _tslib_available:
        return value is NaT
    else:
        return False


# checks if the given value is NaN
def is_nan(value):
    try:
        return math.isnan(value)
    except BaseException:
        return False


def get_type_string(object):
    if hasattr(object, '__module__'):
        return object.__module__ + '.' + object.__class__.__name__
    else:
        return object.__class__.__name__


class TypeExtensionManager:
    def __init__(self):
        self._id_to_index = {}
        self._type_to_id = {}
        self._type_extensions = []
    def get_type_extension_by_id(self, id):
        if id not in self._id_to_index:
            return None
        return self.get_type_extension_by_index(self._id_to_index[id])
    def get_type_extension_by_type(self, type_string):
        if type_string not in self._type_to_id:
            return None
        return self.get_type_extension_by_id(self._type_to_id[type_string])
    def get_id_by_type(self, type_string):
        if type_string not in self._type_to_id:
            return None
        return self._type_to_id[type_string]
    def get_type_extension_by_index(self, index):
        if index >= len(self._type_extensions):
            return None
        type_extension = self._type_extensions[index]
        if type(type_extension) is not types.ModuleType:
            path = type_extension
            last_separator = path.rfind(os.sep)
            file_extension_start = path.rfind('.')
            module_name = path[last_separator+1:file_extension_start]
            try:
                type_extension = imp.load_source(module_name, path)
            except ImportError as e:
                raise ImportError('Error while loading python type extension ' + module_name + '\nCause: ' + str(e))
            self._type_extensions[index] = type_extension
        return type_extension
    def add_type_extension(self, id, type_string, path):
        index = len(self._type_extensions)
        self._type_extensions.append(path)
        self._id_to_index[id] = index
        self._type_to_id[type_string] = id


_type_extension_manager = TypeExtensionManager()


run()
